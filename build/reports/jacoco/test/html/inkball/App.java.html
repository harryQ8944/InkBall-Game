<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>App.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">home</a> &gt; <a href="index.source.html" class="el_package">inkball</a> &gt; <span class="el_source">App.java</span></div><h1>App.java</h1><pre class="source lang-java linenums">package inkball;

import processing.core.PApplet;
import processing.core.PFont;
import processing.core.PImage;
import processing.core.PVector;
import processing.data.JSONArray;
import processing.data.JSONObject;
import processing.event.KeyEvent;
import processing.event.MouseEvent;

import java.io.UnsupportedEncodingException;
import java.net.URLDecoder;
import java.nio.charset.StandardCharsets;

import java.io.*;
import java.util.*;

/**
 * The {@code App} class is the main application class for the Inkball game.
 * It extends {@link PApplet} to utilize the Processing library for graphics and interactions.
 * This class handles game setup, rendering, user input, game logic, and state management.
 * &lt;p&gt;
 * Key functionalities include:
 * &lt;ul&gt;
 *     &lt;li&gt;Loading game configurations and resources&lt;/li&gt;
 *     &lt;li&gt;Managing game states such as score, levels, and time&lt;/li&gt;
 *     &lt;li&gt;Handling user inputs for drawing lines and controlling the game&lt;/li&gt;
 *     &lt;li&gt;Rendering game elements like the grid, balls, tiles, and UI components&lt;/li&gt;
 *     &lt;li&gt;Managing game entities including balls, tiles, spawners, and holes&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;/p&gt;
 *
 * @author HanchengQiu
 * @version 1.0
 * @since 2024-10-27
 */
public class App extends PApplet {

    // Constants for game dimensions and settings
    public static final int TILE_SIZE = 32;
    public static final int GRID_WIDTH = 18; // 576 / 32
    public static final int GRID_HEIGHT = 18; // 576 / 32
    public static final int TOPBAR = 64;
    public static final int WIDTH = TILE_SIZE * GRID_WIDTH; // 576
    public static final int HEIGHT = TILE_SIZE * GRID_HEIGHT + TOPBAR; // 576 + TOPBAR
    public static final int FPS = 30;
    private static final int NEW_FPS = 2; // Number of frames per update for timer and level.
    // One frame is 1/30 ~~ 0.333 per/s, 2 frames is 2x0.33 ~~ 0.067

    // Configuration and Game Resources
    public String configPath;
    public JSONObject config;
    public JSONArray levels;
    public JSONObject currentLevel;
    public PImage background;
    public PImage[] ballImages; // Array to hold the ball images
    public PImage yellowTileImage; // Sprite for yellow tiles

    // Game State Variables
<span class="fc" id="L61">    private boolean isPaused = false;</span>
<span class="fc" id="L62">    private boolean isRestarting = false;</span>
    public boolean isDrawing;
<span class="fc" id="L64">    public boolean levelFinish = false; // Indicates if the level has ended</span>
<span class="fc" id="L65">    private boolean isLevelCompleting = false; // Indicates if the level is in the completion phase</span>

<span class="fc" id="L67">    public int score = 0; // Persistent score across levels</span>
<span class="fc" id="L68">    public int levelStartScore = 0; // Score before the current level started</span>
    public int currentLevelIndex;
    private int spawnFrames; // How many frames between spawns
    private int spawnCount; // Current timer for spawning balls
    private int timeSeconds; // Total time for the level in seconds
    public int timeLeft; // Time remaining in frames
<span class="fc" id="L74">    private int remainTime = 0;</span>
<span class="fc" id="L75">    private int updateScoreFrames = NEW_FPS; // Counter to track frames until the next update</span>

    // Game Entities
    private Tile[][] grid; // 2D array of tiles
    private List&lt;Ball&gt; balls; // Active balls in the game
    private List&lt;Ball&gt; ballsToRemove; // Balls that are marked for removal
    public List&lt;EntryPoint&gt; spawners; // Entry points for spawning balls
    private List&lt;String&gt; ballsToSpawn; // Balls that still need to be spawned
    private List&lt;Hole&gt; holes; // List of holes in the game
    private List&lt;Ball&gt; ballsLoaded; // Balls loaded from file

    // Player Input and Interaction
    public List&lt;Line&gt; Lines; // List to manage multiple player-drawn lines
    public Line drawingLine; // The line currently being drawn

    // Score and Level Configuration
    private Map&lt;String, Integer&gt; scoreWon;
    private Map&lt;String, Integer&gt; scoreLost;

    // Animation and Tile Movement Variables
    public List&lt;PVector&gt; edgePositions;
<span class="fc" id="L96">    private int yellowTile1 = 0;</span>
<span class="fc" id="L97">    private int yellowTile2 = 0;</span>
    private int totalEdgeTiles;

    // Utility Fields
<span class="fc" id="L101">    public static Random random = new Random();</span>

    // Offset for shifting balls in the top bar
<span class="fc" id="L104">    private float ballOffset = 0;</span>
<span class="fc" id="L105">    private final float ballWidth = 30.0f; // Width of one ball as a float</span>
<span class="fc" id="L106">    private final int totalShiftFrames = 30; // Total frames to complete the shift</span>
<span class="fc" id="L107">    private int shiftRemaining = 0; // Frames remaining in the shift animation</span>

    // Timer Font
    PFont monoFont;

    // Load Level
<span class="fc" id="L113">    private String levelLayout = &quot;level1.txt&quot;;</span>

    /**
     * Constructs a new {@code App} instance with the default configuration path.
     */
<span class="fc" id="L118">    public App() {</span>
<span class="fc" id="L119">        this.configPath = &quot;config.json&quot;;</span>
<span class="fc" id="L120">    }</span>

    /**
     * Configures the initial size of the game window.
     * This method is called once when the program starts.
     */
    @Override
    public void settings() {
<span class="fc" id="L128">        size(WIDTH, HEIGHT);</span>
<span class="fc" id="L129">    }</span>

    /**
     * Initializes the game by setting the frame rate, loading resources,
     * initializing game entities, and loading the first level.
     */
    @Override
    public void setup() {
<span class="fc" id="L137">        frameRate(FPS);</span>
<span class="fc" id="L138">        loadImages();</span>
<span class="fc" id="L139">        loadConfig();</span>
<span class="fc" id="L140">        background = loadImage(&quot;src/main/resources/inkball/tile.png&quot;);</span>
<span class="fc" id="L141">        yellowTileImage = loadImage(&quot;src/main/resources/inkball/wall4.png&quot;);</span>

<span class="fc" id="L143">        balls = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L144">        ballsToRemove = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L145">        spawners = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L146">        Lines = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L147">        drawingLine = null;</span>
<span class="fc" id="L148">        holes = new ArrayList&lt;&gt;();</span>

<span class="fc" id="L150">        monoFont = createFont(&quot;Courier&quot;, 20);</span>
<span class="fc" id="L151">        textFont(monoFont);</span>
<span class="fc" id="L152">        loadLevel(currentLevelIndex = 0);</span>
<span class="fc" id="L153">    }</span>

    /**
     * Loads all necessary images for the game, including ball and wall sprites.
     * Images are loaded from the specified resource paths.
     */
    public void loadImages() {
        // Preload ball images (indices 0 to 4)
<span class="fc" id="L161">        ballImages = new PImage[5];</span>
<span class="fc bfc" id="L162" title="All 2 branches covered.">        for (int i = 0; i &lt;= 4; i++) {</span>
<span class="fc" id="L163">            String path = &quot;src/main/resources/inkball/ball&quot; + i + &quot;.png&quot;;</span>
<span class="fc" id="L164">            ballImages[i] = loadImage(path);</span>
        }

        // Preload wall images (indices 0 to 4)
<span class="fc bfc" id="L168" title="All 2 branches covered.">        for (int i = 0; i &lt;= 4; i++) {</span>
<span class="fc" id="L169">            String path = &quot;src/main/resources/inkball/wall&quot; + i + &quot;.png&quot;;</span>
<span class="fc" id="L170">            PImage wallImage = loadImage(path);</span>
<span class="pc bpc" id="L171" title="1 of 2 branches missed.">            if (wallImage == null) {</span>
<span class="nc" id="L172">                System.err.println(&quot;Failed to load wall from: &quot; + path);</span>
            } else {
<span class="fc" id="L174">                System.out.println(&quot;Loaded wall from: &quot; + path);</span>
            }
        }
<span class="fc" id="L177">    }</span>

    /**
     * Loads the game configuration from a JSON file.
     * Initializes scoring maps based on the configuration.
     */
    public void loadConfig() {
<span class="fc" id="L184">        config = loadJSONObject(configPath);</span>
<span class="fc" id="L185">        levels = config.getJSONArray(&quot;levels&quot;);</span>

        // Initialize scoring maps
<span class="fc" id="L188">        scoreWon = new HashMap&lt;&gt;();</span>
<span class="fc" id="L189">        JSONObject increaseScores = config.getJSONObject(&quot;score_increase_from_hole_capture&quot;);</span>
<span class="pc bpc" id="L190" title="1 of 2 branches missed.">        if (increaseScores != null) {</span>
<span class="fc" id="L191">            Set&lt;?&gt; keys = increaseScores.keys(); // Use Set&lt;?&gt; to parameterize the raw type</span>
<span class="fc bfc" id="L192" title="All 2 branches covered.">            for (Object keyObj : keys) {</span>
<span class="fc" id="L193">                String colour = keyObj.toString();</span>
<span class="fc" id="L194">                int score = increaseScores.getInt(colour); // Default to 10 if not found</span>
<span class="fc" id="L195">                scoreWon.put(colour.toLowerCase(), score);</span>
<span class="fc" id="L196">            }</span>
        }
<span class="fc" id="L198">        scoreLost = new HashMap&lt;&gt;();</span>
<span class="fc" id="L199">        JSONObject decreaseScores = config.getJSONObject(&quot;score_decrease_from_wrong_hole&quot;);</span>
<span class="pc bpc" id="L200" title="1 of 2 branches missed.">        if (decreaseScores != null) {</span>
<span class="fc" id="L201">            Set&lt;?&gt; keys = decreaseScores.keys(); // Use Set&lt;?&gt; here as well</span>
<span class="fc bfc" id="L202" title="All 2 branches covered.">            for (Object keyObj : keys) {</span>
<span class="fc" id="L203">                String color = keyObj.toString();</span>
<span class="fc" id="L204">                int penalty = decreaseScores.getInt(color, 5); // Default to 5 if not found</span>
<span class="fc" id="L205">                scoreLost.put(color.toLowerCase(), penalty);</span>
<span class="fc" id="L206">            }</span>
        }
<span class="fc" id="L208">        println(&quot;Config load finishes!&quot;);</span>
<span class="fc" id="L209">    }</span>

    /**
     * Loads a specific level based on the provided index.
     * Initializes level-specific parameters such as spawn intervals and timers.
     *
     * @param i the index of the level to load
     */
    public void loadLevel(int i) {
<span class="pc bpc" id="L218" title="1 of 2 branches missed.">        if (i &gt;= levels.size()) {</span>
<span class="nc" id="L219">            println(&quot;All Levels loaded. Game finishes!&quot;);</span>
<span class="nc" id="L220">            noLoop(); // Stop the game loop</span>
<span class="nc" id="L221">            return;</span>
        }

<span class="fc" id="L224">        Lines.clear();</span>

<span class="fc" id="L226">        currentLevel = levels.getJSONObject(i);</span>
<span class="fc" id="L227">        levelLayout = currentLevel.getString(&quot;layout&quot;);</span>
<span class="fc" id="L228">        loadLevelLayout();</span>

        // Store the current score as the starting score for the level
<span class="fc" id="L231">        levelStartScore = score;</span>

        // Initialize spawn interval
<span class="fc" id="L234">        int spwanTime = currentLevel.getInt(&quot;spawn_interval&quot;);</span>
<span class="fc" id="L235">        spawnFrames = spwanTime * FPS;</span>
<span class="fc" id="L236">        spawnCount = spawnFrames;</span>

        // Load balls to spawn
<span class="fc" id="L239">        ballsToSpawn = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L240">        JSONArray ballsArray = currentLevel.getJSONArray(&quot;balls&quot;);</span>
<span class="fc bfc" id="L241" title="All 2 branches covered.">        for (int j = 0; j &lt; ballsArray.size(); j++) {</span>
<span class="fc" id="L242">            ballsToSpawn.add(ballsArray.getString(j));</span>
        }

        // Initialize level timer
<span class="fc" id="L246">        timeSeconds = currentLevel.getInt(&quot;time&quot;); // Default to 120 seconds if not specified</span>
<span class="fc" id="L247">        timeLeft = timeSeconds * FPS;</span>

        // Reset level flags
<span class="fc" id="L250">        levelFinish = false;</span>
<span class="fc" id="L251">        isLevelCompleting = false;</span>
<span class="fc" id="L252">    }</span>

    /**
     * Loads the layout of the current level from a text file.
     * Initializes tiles, spawners, holes, and preloaded balls based on the layout.
     */
    public void loadLevelLayout() {
<span class="fc" id="L259">        holes.clear(); // Clear existing holes</span>
<span class="fc" id="L260">        spawners.clear(); // Clear existing spawners</span>
<span class="fc" id="L261">        ballsLoaded = new ArrayList&lt;&gt;(); // Initialize the list of balls from the file</span>
<span class="fc" id="L262">        List&lt;String&gt; tokens = Arrays.asList(loadStrings(levelLayout));</span>
<span class="fc" id="L263">        grid = new Tile[GRID_HEIGHT][GRID_WIDTH]; // 2D ArrayList</span>

<span class="fc bfc" id="L265" title="All 2 branches covered.">        for (int y = 0; y &lt; GRID_HEIGHT; y++) {</span>
<span class="pc bpc" id="L266" title="1 of 2 branches missed.">            String line = y &lt; tokens.size() ? tokens.get(y) : &quot;&quot;;</span>
<span class="fc bfc" id="L267" title="All 2 branches covered.">            for (int x = 0; x &lt; GRID_WIDTH; x++) {</span>
<span class="fc" id="L268">                Tile tile = null;</span>
<span class="pc bpc" id="L269" title="1 of 2 branches missed.">                if (x &lt; line.length()) {</span>
<span class="fc" id="L270">                    char c = line.charAt(x);</span>

<span class="fc bfc" id="L272" title="All 2 branches covered.">                    if (c == 'X') {</span>
<span class="fc" id="L273">                        tile = new GreyTile(x, y, this);</span>
<span class="fc" id="L274">                        System.out.println(&quot;Created Wall at (&quot; + x + &quot;, &quot; + y + &quot;)&quot;);</span>
<span class="pc bpc" id="L275" title="2 of 8 branches missed.">                    } else if (c == '1' || c == '2' || c == '3' || c == '4') {</span>
<span class="fc" id="L276">                        int colour = Character.getNumericValue(c);</span>
<span class="fc" id="L277">                        tile = new ColourTile(x, y, colour, this);</span>
<span class="fc bfc" id="L278" title="All 2 branches covered.">                    } else if (c == 'S') {</span>
<span class="fc" id="L279">                        tile = new EntryPoint(x, y, this);</span>
<span class="fc" id="L280">                        spawners.add((EntryPoint) tile); // Collect spawners</span>
<span class="fc" id="L281">                        System.out.println(&quot;Created EntryPoint/Spawner at (&quot; + x + &quot;, &quot; + y + &quot;)&quot;);</span>
<span class="pc bpc" id="L282" title="1 of 4 branches missed.">                    } else if (c == 'H' &amp;&amp; x + 1 &lt; line.length()) {</span>
<span class="fc" id="L283">                        char colourChar = line.charAt(x + 1);</span>
<span class="fc" id="L284">                        int holeColour = Character.getNumericValue(colourChar);</span>
<span class="fc" id="L285">                        putHoles(x, y, holeColour);</span>
<span class="fc" id="L286">                        System.out.println(&quot;Created Hole at (&quot; + x + &quot;, &quot; + y + &quot;) with color index: &quot; + holeColour);</span>
<span class="fc" id="L287">                        x++; // Skip the next character since it's part of the hole definition</span>
<span class="fc" id="L288">                        continue;</span>
<span class="pc bpc" id="L289" title="1 of 4 branches missed.">                    } else if (c == 'B' &amp;&amp; x + 1 &lt; line.length()) {</span>
<span class="fc" id="L290">                        char colourChar = line.charAt(x + 1);</span>
<span class="fc" id="L291">                        int ballColour = Character.getNumericValue(colourChar);</span>
<span class="fc" id="L292">                        Ball ball = new Ball(x * TILE_SIZE, y * TILE_SIZE, ballColour, this);</span>
<span class="fc" id="L293">                        balls.add(ball); // Add to the list of active balls</span>
<span class="fc" id="L294">                        ballsLoaded.add(ball); // Track that this ball was loaded from the file</span>
<span class="fc" id="L295">                        System.out.println(&quot;Created Ball at (&quot; + x + &quot;, &quot; + y + &quot;) with color index: &quot; + ballColour);</span>
<span class="fc" id="L296">                        x++; // Skip the next character since it's part of the ball definition</span>
<span class="fc" id="L297">                    } else {</span>
<span class="fc" id="L298">                        tile = null;</span>
                    }

<span class="fc" id="L301">                    grid[y][x] = tile;</span>
<span class="fc" id="L302">                } else {</span>
<span class="nc" id="L303">                    grid[y][x] = null;</span>
                }
            }
        }
<span class="fc" id="L307">        System.out.println(&quot;Level layout loaded from: &quot; + levelLayout);</span>
<span class="fc" id="L308">        System.out.println(&quot;Number of holes loaded: &quot; + holes.size());</span>
<span class="fc" id="L309">    }</span>

    /**
     * The main drawing loop that is called repeatedly to render the game.
     * It handles rendering of UI components, game elements, and updates game logic.
     */
    @Override
    public void draw() {
<span class="fc" id="L317">        drawTopBar();</span>
<span class="fc" id="L318">        drawBackground();</span>
<span class="fc" id="L319">        drawGrid();</span>
<span class="fc" id="L320">        drawLines();</span>
<span class="fc" id="L321">        spawnCountdown();</span>
<span class="fc" id="L322">        timeDisplay();</span>
<span class="fc" id="L323">        updateBalls();</span>
<span class="fc" id="L324">        HitAnimation();</span>
<span class="fc" id="L325">        scoreUpdates();</span>
<span class="fc" id="L326">        levelCompleteAnimation();</span>
<span class="fc" id="L327">    }</span>

    /**
     * Draws the top bar UI component, including score, timer, upcoming balls,
     * and game status indicators such as pause and level finish.
     */
    public void drawTopBar() {
<span class="fc" id="L334">        fill(192);</span>
<span class="fc" id="L335">        noStroke(); // No outline (stroke) around shapes.</span>
<span class="fc" id="L336">        rect(0, 0, WIDTH, TOPBAR);</span>

        // Define fixed width and height for the black rectangle
<span class="fc" id="L339">        int rectHeight = TOPBAR - 25; // Adjust the height if needed</span>
<span class="fc" id="L340">        int rectWidth = 160;          // Increased width of the black rectangle</span>
<span class="fc" id="L341">        int rectX = 10;</span>
<span class="fc" id="L342">        int rectY = (TOPBAR - rectHeight) / 2; // Center vertically within the top bar</span>

        // Draw black rectangle with the new wider size
<span class="fc" id="L345">        fill(0); // Black color</span>
<span class="fc" id="L346">        rect(rectX, rectY, rectWidth, rectHeight); // Draw at fixed position with updated width</span>

        // Shift balls when shiftRemaining &gt; 0
<span class="pc bpc" id="L349" title="1 of 2 branches missed.">        if (shiftRemaining &gt; 0) {</span>
<span class="nc" id="L350">            float shiftAmount = ballWidth / totalShiftFrames;</span>
<span class="nc" id="L351">            ballOffset += shiftAmount;</span>
<span class="nc" id="L352">            shiftRemaining--;</span>
<span class="nc bnc" id="L353" title="All 2 branches missed.">            if (shiftRemaining == 0) {</span>
<span class="nc" id="L354">                ballOffset = 0;</span>
                // Remove the first ball from ballsToSpawn after shift completes
<span class="nc bnc" id="L356" title="All 2 branches missed.">                if (!ballsToSpawn.isEmpty()) {</span>
<span class="nc" id="L357">                    ballsToSpawn.remove(0);</span>
                }
            }
        }

        // Draw up to 5 upcoming balls in the black rectangle
<span class="fc" id="L363">        int max = 5;</span>
<span class="fc" id="L364">        int ballsToShow = Math.min(ballsToSpawn.size(), max);</span>

<span class="fc bfc" id="L366" title="All 2 branches covered.">        for (int i = 0; i &lt; ballsToShow; i++) {</span>
<span class="fc" id="L367">            String colorString = ballsToSpawn.get(i);</span>
<span class="fc" id="L368">            int colorInt = colourToInt(colorString);</span>
<span class="fc" id="L369">            PImage ballImage = ballImages[colorInt]; // Use preloaded sprites</span>
<span class="fc" id="L370">            int startY = (TOPBAR - 25) / 2; // Center the balls vertically</span>

<span class="fc" id="L372">            float x = rectX + 5 + i * ballWidth - ballOffset;</span>
<span class="pc bpc" id="L373" title="2 of 4 branches missed.">            if (x &gt;= rectX &amp;&amp; x &lt;= rectX + rectWidth - ballWidth) {</span>
<span class="fc" id="L374">                image(ballImage, x, startY); // Draw the ball at the updated position</span>
            }
        }

        // Draw spawn interval countdown only if there are balls to spawn
<span class="pc bpc" id="L379" title="1 of 2 branches missed.">        if (!ballsToSpawn.isEmpty()) {</span>
<span class="fc" id="L380">            fill(0); // Black color for text</span>
<span class="fc" id="L381">            textSize(20);</span>
<span class="fc" id="L382">            textAlign(LEFT, CENTER);</span>
<span class="fc" id="L383">            int countdownX = rectX + rectWidth + 10; // Position to the right of the black rectangle</span>
<span class="fc" id="L384">            String countdownText = String.format(&quot;%.1f&quot;, spawnCount / (float)FPS); // Show as a decimal</span>
<span class="fc" id="L385">            text(countdownText, countdownX, TOPBAR / 2);</span>
        }

        // Draw score and timer on the top bar
<span class="fc" id="L389">        fill(0); // Black color for text</span>
<span class="fc" id="L390">        textSize(20);</span>
<span class="fc" id="L391">        textAlign(LEFT, CENTER); // Anchor text from the left to prevent shifting</span>

        // Define fixed positions for score and timer
<span class="fc" id="L394">        float scoreX = WIDTH - 150; // Fixed x position for score</span>
<span class="fc" id="L395">        float scoreY = TOPBAR / 2 - 14; // y position for score</span>

<span class="fc" id="L397">        float timerX = WIDTH - 138; // Fixed x position for timer</span>
<span class="fc" id="L398">        float timerY = TOPBAR / 2 + 10; // y position for timer</span>

        // Display score with fixed alignment and leading zeros
<span class="fc" id="L401">        String scoreText = String.format(&quot;Score: %03d&quot;, score); // Pads score with leading zeros to 3 digits</span>
<span class="fc" id="L402">        text(scoreText, scoreX, scoreY); // Fixed position</span>

        // Display timer with fixed alignment and leading zeros
<span class="fc" id="L405">        int timeRemaining = timeLeft / FPS;</span>
<span class="fc" id="L406">        String timerText = String.format(&quot;Time: %03d&quot;, timeRemaining); // Pads time with leading zeros to 3 digits</span>
<span class="fc" id="L407">        text(timerText, timerX, timerY); // Fixed position</span>

        // Display end game messages
<span class="pc bpc" id="L410" title="1 of 2 branches missed.">        if (levelFinish) {</span>
<span class="nc" id="L411">            fill(255, 0, 0); // Red color</span>
<span class="nc" id="L412">            textSize(16);</span>
<span class="nc" id="L413">            textAlign(CENTER, CENTER);</span>
<span class="nc bnc" id="L414" title="All 2 branches missed.">            if (currentLevelIndex &gt;= levels.size()) {</span>
                // Game has ended after the last level
<span class="nc" id="L416">                text(&quot;===ENDED===&quot;, WIDTH / 2, TOPBAR / 2);</span>
            } else {
                // Level ended due to time running out
<span class="nc" id="L419">                text(&quot;===TIME'S UP===&quot;, WIDTH / 2, TOPBAR / 2);</span>
            }
        }

        // Display pause indicator if the game is paused
<span class="fc bfc" id="L424" title="All 2 branches covered.">        if (isPaused) {</span>
<span class="fc" id="L425">            fill(255, 0, 0); // Red color for emphasis</span>
<span class="fc" id="L426">            textSize(16);</span>
<span class="fc" id="L427">            textAlign(CENTER, CENTER);</span>
<span class="fc" id="L428">            text(&quot;***PAUSED***&quot;, WIDTH / 2, TOPBAR / 2);</span>
        }
<span class="fc" id="L430">    }</span>

    /**
     * Draws yellow tiles that move along the edges of the game grid.
     * This method is used for visual effects during level completion.
     */
    public void drawYellowTiles() {
        // Draw yellow tile 1
<span class="fc" id="L438">        PVector p1 = edgePositions.get(yellowTile1);</span>
<span class="fc" id="L439">        int x1 = (int) p1.x * TILE_SIZE;</span>
<span class="fc" id="L440">        int y1 = (int) p1.y * TILE_SIZE + TOPBAR;</span>
<span class="fc" id="L441">        image(yellowTileImage, x1, y1, TILE_SIZE, TILE_SIZE); // Draw the sprite at the current position</span>

        // Draw yellow tile 2
<span class="fc" id="L444">        PVector p2 = edgePositions.get(yellowTile2);</span>
<span class="fc" id="L445">        int x2 = (int) p2.x * TILE_SIZE;</span>
<span class="fc" id="L446">        int y2 = (int) p2.y * TILE_SIZE + TOPBAR;</span>
<span class="fc" id="L447">        image(yellowTileImage, x2, y2, TILE_SIZE, TILE_SIZE); // Draw the sprite at the current position</span>
<span class="fc" id="L448">    }</span>

    /**
     * Draws all player-drawn lines on the game area.
     * Lines are not drawn if the level has finished.
     */
    public void drawLines() {
<span class="pc bpc" id="L455" title="1 of 2 branches missed.">        if (!levelFinish) {</span>
<span class="pc bpc" id="L456" title="1 of 2 branches missed.">            for (Line line : Lines) {</span>
<span class="nc" id="L457">                line.draw(this);</span>
<span class="nc" id="L458">            }</span>
        }
<span class="fc" id="L460">    }</span>

    /**
     * Renders the background tiles across the entire game grid.
     */
    private void drawBackground() {
<span class="fc bfc" id="L466" title="All 2 branches covered.">        for (int y = 0; y &lt; GRID_HEIGHT; y++) {</span>
<span class="fc bfc" id="L467" title="All 2 branches covered.">            for (int x = 0; x &lt; GRID_WIDTH; x++) {</span>
<span class="fc" id="L468">                image(background, x * TILE_SIZE, y * TILE_SIZE + TOPBAR);</span>
            }
        }
<span class="fc" id="L471">    }</span>

    /**
     * Draws all tiles present in the game grid.
     * Also updates cooldowns for GreyTiles and ColourTiles.
     */
    public void drawGrid() {
<span class="fc bfc" id="L478" title="All 2 branches covered.">        for (int y = 0; y &lt; GRID_HEIGHT; y++) {</span>
<span class="fc bfc" id="L479" title="All 2 branches covered.">            for (int x = 0; x &lt; GRID_WIDTH; x++) {</span>
<span class="fc" id="L480">                Tile tile = grid[y][x];</span>
<span class="fc bfc" id="L481" title="All 2 branches covered.">                if (tile != null) {</span>
<span class="fc" id="L482">                    tile.draw(this);</span>
                }
<span class="fc bfc" id="L484" title="All 2 branches covered.">                if (tile instanceof GreyTile) {</span>
<span class="fc" id="L485">                    ((GreyTile) tile).updateCooldown();</span>
<span class="pc bpc" id="L486" title="1 of 2 branches missed.">                } else if (tile instanceof ColourTile) {</span>
<span class="nc" id="L487">                    ((ColourTile) tile).updateCooldown();</span>
                }
            }
        }
<span class="fc" id="L491">    }</span>

    /**
     * Handles all game logic and updates, including rendering,
     * spawning balls, updating timers, and managing game state transitions.
     */
    // (Note: This comment block is a placeholder as detailed JavaDoc is provided for individual methods.)

    /**
     * Adds holes to the game grid based on the specified position and color.
     * Holes occupy a 2x2 tile area and are initialized with their position and color.
     *
     * @param x      the x-coordinate of the hole's top-left tile
     * @param y      the y-coordinate of the hole's top-left tile
     * @param colour the color index of the hole
     */
    public void putHoles(int x, int y, int colour) {
<span class="fc bfc" id="L508" title="All 2 branches covered.">        for (int dy = 0; dy &lt; 2; dy++) {</span>
<span class="fc bfc" id="L509" title="All 2 branches covered.">            for (int dx = 0; dx &lt; 2; dx++) {</span>
<span class="fc" id="L510">                int nx = x + dx;</span>
<span class="fc" id="L511">                int ny = y + dy;</span>
<span class="pc bpc" id="L512" title="2 of 4 branches missed.">                if (nx &lt; GRID_WIDTH &amp;&amp; ny &lt; GRID_HEIGHT) {</span>
<span class="fc bfc" id="L513" title="All 2 branches covered.">                    if (grid[ny][nx] == null) {</span>
<span class="fc bfc" id="L514" title="All 4 branches covered.">                        boolean isDefult = (dx == 0 &amp;&amp; dy == 0); // Only true for top-left tile</span>
<span class="fc" id="L515">                        grid[ny][nx] = new HoleTile(nx, ny, colour, this, isDefult);</span>
<span class="fc bfc" id="L516" title="All 2 branches covered.">                        if (isDefult) {</span>
                            // Compute the rectangular area of the hole using PVector
<span class="fc" id="L518">                            PVector holePosition = new PVector(x * TILE_SIZE, y * TILE_SIZE + TOPBAR);</span>
<span class="fc" id="L519">                            PVector holeDimensions = new PVector(TILE_SIZE * 2, TILE_SIZE * 2);</span>

                            // Create the Hole object with position and dimensions
<span class="fc" id="L522">                            Hole hole = new Hole(holePosition, holeDimensions, colour);</span>
<span class="fc" id="L523">                            holes.add(hole);</span>
<span class="fc" id="L524">                            System.out.println(&quot;Put Hole at center: &quot; + hole.getCenter() + &quot; with colour &quot; + colour);</span>
                        }
<span class="fc" id="L526">                    } else {</span>
<span class="fc" id="L527">                        System.err.println(&quot;Warning: Overlapping hole at (&quot; + nx + &quot;, &quot; + ny + &quot;)&quot;);</span>
                    }
                }
            }
        }
<span class="fc" id="L532">    }</span>

    /**
     * Spawns a new ball at a random spawner if there are balls left to spawn.
     * Initiates a shift animation for the upcoming balls in the top bar.
     */
    public void spawnBall() {
<span class="nc bnc" id="L539" title="All 4 branches missed.">        if (!ballsToSpawn.isEmpty() &amp;&amp; !spawners.isEmpty()) {</span>
            // Get the first ball from the list of balls to spawn
<span class="nc" id="L541">            String nextBallColour = ballsToSpawn.get(0); // Do not remove yet</span>

            // Convert the colour to the corresponding integer (0-4)
<span class="nc" id="L544">            int colourInt = colourToInt(nextBallColour);</span>

            // Select a random spawner to spawn the ball from
<span class="nc" id="L547">            EntryPoint spawner = spawners.get(random.nextInt(spawners.size()));</span>

            // Create and add the new ball
<span class="nc" id="L550">            Ball newBall = new Ball(spawner.getX() * TILE_SIZE, spawner.getY() * TILE_SIZE, colourInt, this);</span>
<span class="nc" id="L551">            balls.add(newBall);</span>

            // Trigger the gradual shift to the left for remaining balls
<span class="nc" id="L554">            shiftRemaining = totalShiftFrames; // Start shifting by 40 pixels (one ball width)</span>
        }
<span class="nc" id="L556">    }</span>

    /**
     * Manages the countdown for spawning balls.
     * Decrements the spawn counter and spawns a new ball when the counter reaches zero.
     */
    public void spawnCountdown() {
<span class="pc bpc" id="L563" title="2 of 6 branches missed.">        if (!isPaused &amp;&amp; !levelFinish &amp;&amp; !isLevelCompleting) {</span>
<span class="pc bpc" id="L564" title="3 of 4 branches missed.">            if (spawnCount &lt;= 0 &amp;&amp; !ballsToSpawn.isEmpty()) {</span>
<span class="nc" id="L565">                spawnBall();</span>
<span class="nc" id="L566">                spawnCount = spawnFrames; // Reset counter after spawning</span>
<span class="pc bpc" id="L567" title="1 of 2 branches missed.">            } else if (!ballsToSpawn.isEmpty()) {</span>
<span class="fc" id="L568">                spawnCount--;</span>
            }
        }
<span class="fc" id="L571">    }</span>

    /**
     * Displays and updates the remaining time for the current level.
     * Handles level termination when time runs out.
     */
    public void timeDisplay() {
<span class="pc bpc" id="L578" title="2 of 6 branches missed.">        if (!isPaused &amp;&amp; !levelFinish &amp;&amp; !isLevelCompleting) {</span>
            // Decrease level time remaining
<span class="pc bpc" id="L580" title="1 of 2 branches missed.">            if (timeLeft &gt; 0) {</span>
<span class="fc" id="L581">                timeLeft--;</span>
<span class="nc bnc" id="L582" title="All 2 branches missed.">            } else if (!levelFinish) {</span>
                // Level time is up, handle level end as a loss
<span class="nc" id="L584">                checkLoseOrNot();</span>
            }
        }
<span class="fc" id="L587">    }</span>

    /**
     * Updates the state of all active balls, including their positions and rendering.
     * Also checks for level completion conditions.
     */
    public void updateBalls() {
<span class="pc bpc" id="L594" title="1 of 2 branches missed.">        if (!levelFinish) {</span>
<span class="fc bfc" id="L595" title="All 2 branches covered.">            for (Ball ball : balls) {</span>
<span class="fc" id="L596">                ball.update();</span>
<span class="fc" id="L597">                ball.draw();</span>
<span class="fc" id="L598">            }</span>
<span class="fc" id="L599">            balls.removeIf(ball -&gt; ball.isCaptured()); // Remove captured balls</span>
<span class="fc" id="L600">            balls.removeAll(ballsToRemove);</span>
<span class="fc" id="L601">            ballsToRemove.clear();</span>

            // Check for level completion (win condition)
<span class="pc bpc" id="L604" title="4 of 6 branches missed.">            if (!isLevelCompleting &amp;&amp; ballsToSpawn.isEmpty() &amp;&amp; balls.isEmpty()) {</span>
<span class="nc" id="L605">                checkWinOrNot();</span>
            }
        } else {
            // Draw balls without updating to keep them on screen
<span class="nc bnc" id="L609" title="All 2 branches missed.">            for (Ball ball : balls) {</span>
<span class="nc" id="L610">                ball.draw();</span>
<span class="nc" id="L611">            }</span>
        }
<span class="fc" id="L613">    }</span>

    /**
     * Animates the movement of yellow tiles along the edges of the grid.
     * Updates their positions based on the total number of edge tiles.
     */
    public void moveYellowTiles() {
        // Move yellow tile 1 clockwise
<span class="fc" id="L621">        yellowTile1 = (yellowTile1 + 1) % totalEdgeTiles;</span>

        // Move yellow tile 2 clockwise
<span class="fc" id="L624">        yellowTile2 = (yellowTile2 + 1) % totalEdgeTiles;</span>

        // Draw yellow tiles at their new positions
<span class="fc" id="L627">        drawYellowTiles();</span>
<span class="fc" id="L628">    }</span>

    /**
     * Detects and processes score updates based on remaining time and game events.
     * Decreases the timer, increases the score, and moves yellow tiles.
     * Concludes the level if the timer reaches zero.
     */
    public void scoreUpdateDetection() {
        // Only perform updates if there is remaining time
<span class="pc bpc" id="L637" title="1 of 2 branches missed.">        if (timeLeft &gt; 0) {</span>
            // 1. Decrease Timer by 1 second
<span class="fc" id="L639">            timeLeft -= FPS; // Since timeLeft is in frames</span>
<span class="fc" id="L640">            println(&quot;Timer decreased by 1 second. Time remaining: &quot; + (timeLeft / FPS) + &quot;s&quot;);</span>

            // 2. Increase Score by 1
<span class="fc" id="L643">            score += 1;</span>
<span class="fc" id="L644">            System.out.println(&quot;\n\n&quot;);</span>
<span class="fc" id="L645">            println(&quot;Score increased by 1. Current score: &quot; + score);</span>

            // 3. Move Yellow Tiles by 1 tile
<span class="fc" id="L648">            moveYellowTiles();</span>
<span class="fc" id="L649">            println(&quot;Yellow tiles moved by 1 tile.&quot;);</span>

            // Decrement the remaining time to add
<span class="pc bpc" id="L652" title="1 of 2 branches missed.">            if (remainTime &gt; 0) {</span>
<span class="fc" id="L653">                remainTime--;</span>
            }
        } else {
            // Timer has reached zero, conclude the level completion phase
<span class="nc" id="L657">            isLevelFinished();</span>
        }
<span class="fc" id="L659">    }</span>

    /**
     * Handles periodic score updates based on the game's frame rate.
     * This method is called within the main draw loop to ensure timely updates.
     */
    public void scoreUpdates() {
<span class="pc bpc" id="L666" title="3 of 4 branches missed.">        if (isLevelCompleting &amp;&amp; !isPaused) {</span>
<span class="nc bnc" id="L667" title="All 2 branches missed.">            if (updateScoreFrames &lt;= 0) {</span>
<span class="nc" id="L668">                scoreUpdateDetection();</span>
<span class="nc" id="L669">                updateScoreFrames = NEW_FPS; // Reset the counter</span>
            } else {
<span class="nc" id="L671">                updateScoreFrames--;</span>
            }
        }
<span class="fc" id="L674">    }</span>

    /**
     * Creates a list of positions along the edges of the grid.
     * This list is used for animating yellow tiles around the perimeter.
     *
     * @return a list of {@link PVector} representing edge positions
     */
    public List&lt;PVector&gt; createEdges() {
<span class="fc" id="L683">        List&lt;PVector&gt; positions = new ArrayList&lt;&gt;();</span>
        // Top edge (left to right)
<span class="fc bfc" id="L685" title="All 2 branches covered.">        for (int x = 0; x &lt; GRID_WIDTH; x++) {</span>
<span class="fc" id="L686">            positions.add(new PVector(x, 0));</span>
        }
        // Right edge (top to bottom)
<span class="fc bfc" id="L689" title="All 2 branches covered.">        for (int y = 1; y &lt; GRID_HEIGHT; y++) {</span>
<span class="fc" id="L690">            positions.add(new PVector(GRID_WIDTH - 1, y));</span>
        }
        // Bottom edge (right to left)
<span class="fc bfc" id="L693" title="All 2 branches covered.">        for (int x = GRID_WIDTH - 2; x &gt;= 0; x--) {</span>
<span class="fc" id="L694">            positions.add(new PVector(x, GRID_HEIGHT - 1));</span>
        }
        // Left edge (bottom to top)
<span class="fc bfc" id="L697" title="All 2 branches covered.">        for (int y = GRID_HEIGHT - 2; y &gt; 0; y--) {</span>
<span class="fc" id="L698">            positions.add(new PVector(0, y));</span>
        }
<span class="fc" id="L700">        return positions;</span>
    }

    /**
     * Checks if the player has met the win conditions for the current level.
     * If conditions are met, initiates the level completion phase.
     */
    public void checkWinOrNot() {
<span class="fc" id="L708">        isLevelCompleting = true;</span>
<span class="fc" id="L709">        println(&quot;Level completed successfully!&quot;);</span>

        // Add remaining time to score at the specified rate
<span class="fc" id="L712">        remainTime = timeLeft / FPS; // Convert remaining frames to seconds</span>
<span class="fc" id="L713">        println(&quot;Remaining time to add: &quot; + remainTime + &quot; seconds&quot;);</span>

        // Initialize edge positions for yellow tile animations
<span class="fc" id="L716">        edgePositions = createEdges();</span>
<span class="fc" id="L717">        totalEdgeTiles = edgePositions.size();</span>

<span class="fc" id="L719">        yellowTile1 = 0; // Starting position for the first yellow tile</span>
<span class="fc" id="L720">        yellowTile2 = totalEdgeTiles / 2; // Starting position for the second yellow tile</span>
<span class="fc" id="L721">        println(&quot;Yellow Tiles starting at indices: &quot; + yellowTile1 + &quot;, &quot; + yellowTile2);</span>

        // Reset frame counters for animation
<span class="fc" id="L724">        updateScoreFrames = 2; // 1 unit every 0.067 seconds at ~30 FPS</span>

        // Stop spawning and updating balls
<span class="fc" id="L727">        ballsToSpawn.clear();</span>
<span class="fc" id="L728">        balls.clear();</span>
<span class="fc" id="L729">    }</span>

    /**
     * Handles the scenario when the player loses the level due to time running out.
     * Sets the appropriate flags to indicate level completion.
     */
    public void checkLoseOrNot() {
<span class="fc" id="L736">        levelFinish = true;</span>
<span class="fc" id="L737">        timeLeft = 0; // Ensure the timer is exactly zero</span>
<span class="fc" id="L738">        println(&quot;No time left! Level ended!.&quot;);</span>
<span class="fc" id="L739">    }</span>

    /**
     * Checks if the level completion animations and score updates are done.
     * If so, proceeds to the next level or ends the game.
     */
    public void checkCompleteOrNot() {
        // Check if it's time to update
<span class="nc bnc" id="L747" title="All 2 branches missed.">        if (updateScoreFrames &lt;= 0) {</span>
            // Perform score update
<span class="nc" id="L749">            scoreUpdateDetection();</span>
<span class="nc" id="L750">            updateScoreFrames = NEW_FPS; // Reset the counter</span>
        } else {
<span class="nc" id="L752">            updateScoreFrames--;</span>
        }

        // Draw yellow tiles
<span class="nc" id="L756">        drawYellowTiles();</span>

        // Check if all remaining time has been added and tiles have completed a full loop
<span class="nc bnc" id="L759" title="All 6 branches missed.">        if (remainTime &lt;= 0 &amp;&amp; yellowTile1 == 0 &amp;&amp; yellowTile2 == totalEdgeTiles / 2) {</span>
            // Proceed to next level or end game
<span class="nc bnc" id="L761" title="All 2 branches missed.">            if (currentLevelIndex + 1 &lt; levels.size()) {</span>
<span class="nc" id="L762">                currentLevelIndex++;</span>
<span class="nc" id="L763">                loadLevel(currentLevelIndex);</span>
<span class="nc" id="L764">                isLevelCompleting = false;</span>
<span class="nc" id="L765">                println(&quot;Proceeding to the next level: &quot; + currentLevelIndex);</span>
            } else {
                // No more levels, end the game
<span class="nc" id="L768">                levelFinish = true;</span>
<span class="nc" id="L769">                println(&quot;Game has ended.&quot;);</span>
            }
        }
<span class="nc" id="L772">    }</span>

    /**
     * Manages the level completion animations and transitions.
     * Called within the main draw loop to ensure smooth animations.
     */
    public void levelCompleteAnimation() {
<span class="pc bpc" id="L779" title="1 of 2 branches missed.">        if (isLevelCompleting) {</span>
<span class="nc" id="L780">            checkCompleteOrNot();</span>
        }
<span class="fc" id="L782">    }</span>

    /**
     * Finalizes the level by resetting completion flags and loading the next level
     * or ending the game if all levels are completed.
     */
    private void isLevelFinished() {
<span class="nc" id="L789">        isLevelCompleting = false; // Exit the completion phase</span>
<span class="nc" id="L790">        println(&quot;All Level has finished!&quot;);</span>
<span class="nc" id="L791">        println(&quot;\n\n&quot;);</span>

        // Proceed to the next level or end the game
<span class="nc bnc" id="L794" title="All 2 branches missed.">        if (currentLevelIndex + 1 &lt; levels.size()) {</span>
<span class="nc" id="L795">            currentLevelIndex++;</span>
<span class="nc" id="L796">            loadLevel(currentLevelIndex);</span>
<span class="nc" id="L797">            println(&quot;Proceed to the next level: &quot; + currentLevelIndex);</span>
<span class="nc" id="L798">            println(&quot;\n\n&quot;);</span>
        } else {
<span class="nc" id="L800">            levelFinish = true;</span>
<span class="nc" id="L801">            currentLevelIndex = levels.size();</span>
<span class="nc" id="L802">            println(&quot;All level loaded. Game ended!&quot;);</span>
        }
<span class="nc" id="L804">    }</span>

    /**
     * Handles collision detection and response between balls and tiles.
     * Applies damage or captures balls based on tile types and interactions.
     */
    public void HitAnimation() {
<span class="fc bfc" id="L811" title="All 2 branches covered.">        for (Ball ball : balls) {</span>
            // Determine which tile the ball is over
<span class="fc" id="L813">            int tileX = (int)(ball.getPosition().x / Tile.TILE_SIZE);</span>
<span class="fc" id="L814">            int tileY = (int)((ball.getPosition().y - TOPBAR) / Tile.TILE_SIZE);</span>

            // Boundary checks
<span class="pc bpc" id="L817" title="4 of 8 branches missed.">            if (tileX &lt; 0 || tileX &gt;= GRID_WIDTH || tileY &lt; 0 || tileY &gt;= GRID_HEIGHT) {</span>
<span class="nc" id="L818">                continue;</span>
            }

<span class="fc" id="L821">            Tile tile = grid[tileY][tileX];</span>
<span class="pc bpc" id="L822" title="1 of 2 branches missed.">            if (tile instanceof GreyTile) {</span>
<span class="nc" id="L823">                GreyTile wall = (GreyTile) tile;</span>
<span class="nc" id="L824">                wall.getsHit(ball); // Pass the Ball object to the hit method</span>
<span class="nc bnc" id="L825" title="All 2 branches missed.">                if (tile instanceof ColourTile) {</span>
<span class="nc" id="L826">                    ColourTile Cwall = (ColourTile) tile;</span>
<span class="nc" id="L827">                    Cwall.getsHit(ball); // Apply damage based on color matching</span>
<span class="nc" id="L828">                } else {</span>
<span class="nc" id="L829">                    wall.getsHit(ball); // Apply damage for grey walls</span>
                }
            }
<span class="fc" id="L832">        }</span>
<span class="fc" id="L833">    }</span>

    /**
     * Handles key press events.
     * Currently listens for the 'R' key to restart the game.
     *
     * @param event the key event triggered by the user
     */
    @Override
    public void keyPressed(KeyEvent event) {
<span class="nc bnc" id="L843" title="All 4 branches missed.">        if (key == 'r' || key == 'R') {</span>
<span class="nc bnc" id="L844" title="All 2 branches missed.">            if (!isRestarting) {</span>
<span class="nc" id="L845">                isRestarting = true;</span>
<span class="nc" id="L846">                restart();</span>
<span class="nc" id="L847">                isRestarting = false;</span>
            }
        }
<span class="nc" id="L850">    }</span>

    /**
     * Handles key release events.
     * Currently listens for the spacebar to toggle the pause state.
     *
     * @param event the key event triggered by the user
     */
    @Override
    public void keyReleased(KeyEvent event){
<span class="nc bnc" id="L860" title="All 2 branches missed.">        if (event.getKey() == ' ') {</span>
<span class="nc" id="L861">            Pause();</span>
        }
<span class="nc" id="L863">    }</span>

    /**
     * Handles mouse press events.
     * Allows the player to start drawing lines or remove existing lines based on the mouse button.
     */
    @Override
    public void mousePressed() {

<span class="pc bpc" id="L872" title="2 of 4 branches missed.">        if (levelFinish || isLevelCompleting) {</span>
<span class="nc" id="L873">            return; // Prevent drawing lines when the game is paused, ended, or completing</span>
        }

<span class="pc bpc" id="L876" title="1 of 2 branches missed.">        if (mouseButton == LEFT) {</span>
            // Check if the mouse is below the top bar
<span class="pc bpc" id="L878" title="1 of 2 branches missed.">            if (mouseY &gt; TOPBAR) {</span>
                // Start a new line if Ctrl is not pressed
<span class="pc bpc" id="L880" title="5 of 6 branches missed.">                if (!keyPressed || (key != CODED &amp;&amp; keyCode != CONTROL)) {</span>
<span class="fc" id="L881">                    drawingLine = new Line();</span>
<span class="fc" id="L882">                    drawingLine.addPoint(new PVector(mouseX, mouseY));</span>
<span class="fc" id="L883">                    Lines.add(drawingLine);</span>
                }
            }
<span class="nc bnc" id="L886" title="All 2 branches missed.">        } else if (mouseButton == RIGHT) {</span>
            // Only allow removing lines if clicked below the top bar
<span class="nc bnc" id="L888" title="All 2 branches missed.">            if (mouseY &gt; TOPBAR) {</span>
                // Remove the nearest line upon right-click
<span class="nc" id="L890">                removeLine(new PVector(mouseX, mouseY));</span>
            }
        }
<span class="fc" id="L893">    }</span>

    /**
     * Handles mouse drag events.
     * Continues drawing the current line as the mouse is dragged.
     */
    @Override
    public void mouseDragged() {

<span class="pc bpc" id="L902" title="2 of 4 branches missed.">        if (levelFinish || isLevelCompleting) {</span>
<span class="nc" id="L903">            return; // Prevent drawing lines when the game is paused, ended, or completing</span>
        }
<span class="pc bpc" id="L905" title="2 of 4 branches missed.">        if (drawingLine != null &amp;&amp; mouseButton == LEFT) {</span>
            // Only add points if dragging within the game area
<span class="pc bpc" id="L907" title="1 of 2 branches missed.">            if (mouseY &gt; TOPBAR) {</span>
<span class="fc" id="L908">                drawingLine.addPoint(new PVector(mouseX, mouseY));</span>
            } else {
<span class="nc" id="L910">                println();</span>
<span class="nc" id="L911">                println(&quot;Cannot draw it here!!!&quot;);</span>
            }
        }
<span class="fc" id="L914">    }</span>

    /**
     * Handles mouse release events.
     * Finalizes the current line being drawn if applicable.
     *
     * @param event the mouse event triggered by the user
     */
    @Override
    public void mouseReleased(MouseEvent event) {
<span class="pc bpc" id="L924" title="3 of 4 branches missed.">        if (isDrawing &amp;&amp; drawingLine != null) {</span>
<span class="nc" id="L925">            finishDrawing();</span>
        }
<span class="fc" id="L927">    }</span>

    /**
     * Finalizes the drawing of a line by adding it to the list of lines
     * if it contains more than one point.
     */
    public void finishDrawing() {
<span class="pc bpc" id="L934" title="2 of 4 branches missed.">        if (drawingLine != null &amp;&amp; drawingLine.getPoints().size() &gt; 1) {</span>
<span class="nc" id="L935">            Lines.add(drawingLine);</span>
        }
<span class="fc" id="L937">        drawingLine = null;</span>
<span class="fc" id="L938">        isDrawing = false;</span>
<span class="fc" id="L939">    }</span>

    /**
     * Calculates the minimum distance between a point and a line.
     *
     * @param point the point to measure from
     * @param line  the line to measure to
     * @return the minimum distance between the point and the line
     */
    public float lineRemoveDistance(PVector point, Line line) {
<span class="fc" id="L949">        float lineRemoveDistance = Float.MAX_VALUE;</span>
<span class="pc bpc" id="L950" title="1 of 2 branches missed.">        for (int i = 0; i &lt; line.getPoints().size() - 1; i++) {</span>
<span class="nc" id="L951">            PVector p1 = line.getPoints().get(i);</span>
<span class="nc" id="L952">            PVector p2 = line.getPoints().get(i + 1);</span>
<span class="nc" id="L953">            float distance = line.nearLineDistance(point, p1, p2);</span>
<span class="nc bnc" id="L954" title="All 2 branches missed.">            if (distance &lt; lineRemoveDistance) {</span>
<span class="nc" id="L955">                lineRemoveDistance = distance;</span>
            }
        }
<span class="fc" id="L958">        return lineRemoveDistance;</span>
    }

    /**
     * Removes the closest line to a given point from the list of player-drawn lines.
     *
     * @param point the point near which to find and remove a line
     */
    public void removeLine(PVector point) {
<span class="fc" id="L967">        Line Line = null;</span>
<span class="fc" id="L968">        float lineRemoveDistance = Float.MAX_VALUE;</span>

<span class="fc bfc" id="L970" title="All 2 branches covered.">        for (Line line : Lines) {</span>
            // Calculate the distance from the point to the line
<span class="fc" id="L972">            float distance = lineRemoveDistance(point, line);</span>
<span class="pc bpc" id="L973" title="1 of 2 branches missed.">            if (distance &lt; lineRemoveDistance) {</span>
<span class="nc" id="L974">                lineRemoveDistance = distance;</span>
<span class="nc" id="L975">                Line = line;</span>
            }
<span class="fc" id="L977">        }</span>

<span class="pc bpc" id="L979" title="1 of 2 branches missed.">        if (Line != null) {</span>
<span class="nc" id="L980">            Lines.remove(Line);</span>
<span class="nc" id="L981">            System.out.println();</span>
<span class="nc" id="L982">            println(&quot;A line has been removed!&quot;);</span>
<span class="nc" id="L983">            System.out.println();</span>
        }
<span class="fc" id="L985">    }</span>

    /**
     * Restarts the game by clearing all game entities, resetting scores,
     * and reloading the current or initial level based on the game state.
     */
    public void restart() {
<span class="fc" id="L992">        System.out.println(&quot;\n\n\n&quot;);</span>
<span class="fc" id="L993">        System.out.println(&quot;Wanna Restart? OK ..... Restarting ...&quot;);</span>
<span class="fc" id="L994">        System.out.println();</span>

        // Clear active balls
<span class="fc" id="L997">        balls.clear();</span>
<span class="fc" id="L998">        ballsToRemove.clear();</span>
<span class="fc" id="L999">        ballsLoaded.clear();</span>

        // Clear spawners
<span class="fc" id="L1002">        spawners.clear();</span>

        // Clear player-drawn lines
<span class="fc" id="L1005">        Lines.clear();</span>

        // Reset
<span class="pc bpc" id="L1008" title="3 of 4 branches missed.">        if (levelFinish &amp;&amp; currentLevelIndex &gt;= levels.size()) {</span>
            // Game has ended after the last level, reset score to initial value
<span class="nc" id="L1010">            score = 0;</span>
            // Reset to initial level (level 0)
<span class="nc" id="L1012">            currentLevelIndex = 0;</span>
<span class="nc" id="L1013">            println(&quot;Restarting from the initial level.&quot;);</span>
        } else {
            // Restart the current level, keep the score as levelStartScore
<span class="fc" id="L1016">            score = levelStartScore;</span>
<span class="fc" id="L1017">            println(&quot;Restarting the current level: &quot; + currentLevelIndex);</span>
        }

        // Load the appropriate level
<span class="fc" id="L1021">        loadLevel(currentLevelIndex);</span>

        // Reset spawn counters
<span class="fc" id="L1024">        JSONObject currentLevel = levels.getJSONObject(currentLevelIndex);</span>
<span class="pc bpc" id="L1025" title="1 of 2 branches missed.">        if (currentLevel != null) {</span>
<span class="fc" id="L1026">            int spwanTime = currentLevel.getInt(&quot;spawn_interval&quot;); // Default to 10 seconds</span>
<span class="fc" id="L1027">            spawnFrames = spwanTime * FPS;</span>
<span class="fc" id="L1028">            spawnCount = spawnFrames;</span>

            // Reset level timer
<span class="fc" id="L1031">            timeSeconds = currentLevel.getInt(&quot;time&quot;);</span>
<span class="fc" id="L1032">            timeLeft = timeSeconds * FPS;</span>
        }

        // Reset level completion flags
<span class="fc" id="L1036">        levelFinish = false;</span>
<span class="fc" id="L1037">        isLevelCompleting = false;</span>
<span class="fc" id="L1038">        System.out.println();</span>
<span class="fc" id="L1039">        System.out.println(&quot;Restart Finished!&quot;);</span>
<span class="fc" id="L1040">        System.out.println(&quot;\n\n\n&quot;);</span>
<span class="pc bpc" id="L1041" title="3 of 4 branches missed.">        if (levelFinish &amp;&amp; currentLevelIndex &gt;= levels.size()) {</span>
<span class="nc" id="L1042">            System.out.println(&quot;Game restarted from the initial level!&quot;);</span>
        } else {
<span class="fc" id="L1044">            System.out.println(&quot;Current level restarted!&quot;);</span>
        }
<span class="fc" id="L1046">        System.out.println(&quot;\n\n\n&quot;);</span>
<span class="fc" id="L1047">    }</span>

    /**
     * Converts a color name string to its corresponding integer index.
     *
     * @param colorString the name of the color (e.g., &quot;grey&quot;, &quot;orange&quot;)
     * @return the integer index representing the color
     */
    public int colourToInt(String colorString) {
<span class="fc" id="L1056">        colorString = colorString.toLowerCase();</span>
<span class="fc bfc" id="L1057" title="All 2 branches covered.">        if (colorString.equals(&quot;grey&quot;)) {</span>
<span class="fc" id="L1058">            return 0;</span>
<span class="fc bfc" id="L1059" title="All 2 branches covered.">        } else if (colorString.equals(&quot;orange&quot;)) {</span>
<span class="fc" id="L1060">            return 1;</span>
<span class="fc bfc" id="L1061" title="All 2 branches covered.">        } else if (colorString.equals(&quot;blue&quot;)) {</span>
<span class="fc" id="L1062">            return 2;</span>
<span class="pc bpc" id="L1063" title="1 of 2 branches missed.">        } else if (colorString.equals(&quot;green&quot;)) {</span>
<span class="fc" id="L1064">            return 3;</span>
<span class="nc bnc" id="L1065" title="All 2 branches missed.">        } else if (colorString.equals(&quot;yellow&quot;)) {</span>
<span class="nc" id="L1066">            return 4;</span>
        } else {
<span class="nc" id="L1068">            return 0; // Default case</span>
        }
    }

    /**
     * Converts a color index to its corresponding color name string.
     *
     * @param colorInt the integer index representing the color
     * @return the name of the color as a string
     */
    public String colourToString(int colorInt) {
<span class="pc bpc" id="L1079" title="1 of 2 branches missed.">        if (colorInt == 0) {</span>
<span class="fc" id="L1080">            return &quot;grey&quot;;</span>
<span class="nc bnc" id="L1081" title="All 2 branches missed.">        } else if (colorInt == 1) {</span>
<span class="nc" id="L1082">            return &quot;orange&quot;;</span>
<span class="nc bnc" id="L1083" title="All 2 branches missed.">        } else if (colorInt == 2) {</span>
<span class="nc" id="L1084">            return &quot;blue&quot;;</span>
<span class="nc bnc" id="L1085" title="All 2 branches missed.">        } else if (colorInt == 3) {</span>
<span class="nc" id="L1086">            return &quot;green&quot;;</span>
<span class="nc bnc" id="L1087" title="All 2 branches missed.">        } else if (colorInt == 4) {</span>
<span class="nc" id="L1088">            return &quot;yellow&quot;;</span>
        } else {
<span class="nc" id="L1090">            return &quot;grey&quot;; // Default case</span>
        }
    }


    /**
     * Retrieves the current game grid.
     *
     * @return a 2D array of {@link Tile} representing the game grid
     */
    public Tile[][] getGrid() {
<span class="fc" id="L1101">        return grid;</span>
    }

    /**
     * Retrieves the ball image corresponding to the given color index.
     *
     * @param i the color index of the ball
     * @return the {@link PImage} representing the ball's color, or {@code null} if invalid
     */
    public PImage getBallColourIndex(int i) {
<span class="pc bpc" id="L1111" title="2 of 4 branches missed.">        if (i &gt;= 0 &amp;&amp; i &lt; ballImages.length) {</span>
<span class="fc" id="L1112">            return ballImages[i];</span>
        } else {
<span class="nc" id="L1114">            System.err.println(&quot;Invalid sprite index: &quot; + i);</span>
<span class="nc" id="L1115">            return null;</span>
        }
    }

    /**
     * Retrieves the tile at the specified grid coordinates.
     *
     * @param x the x-coordinate in the grid
     * @param y the y-coordinate in the grid
     * @return the {@link Tile} at the specified position, or {@code null} if out of bounds
     */
    public Tile getTile(int x, int y) {
<span class="pc bpc" id="L1127" title="4 of 8 branches missed.">        if (x &gt;= 0 &amp;&amp; x &lt; GRID_WIDTH &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; GRID_HEIGHT) {</span>
<span class="fc" id="L1128">            return grid[y][x];</span>
        } else {
<span class="nc" id="L1130">            return null;</span>
        }
    }

    /**
     * Retrieves the list of holes present in the game.
     *
     * @return a list of {@link Hole} objects
     */
    public List&lt;Hole&gt; getHoles() {
<span class="fc" id="L1140">        return holes;</span>
    }

    /**
     * Retrieves the array of preloaded ball images.
     *
     * @return an array of {@link PImage} representing ball sprites
     */
    public PImage[] getBallImages() {
<span class="fc" id="L1149">        return ballImages;</span>
    }

    /**
     * Toggles the pause state of the game.
     * When paused, the game loop stops updating; when unpaused, it resumes.
     */
    protected void Pause() {
<span class="pc bpc" id="L1157" title="1 of 2 branches missed.">        isPaused = !isPaused;</span>
<span class="pc bpc" id="L1158" title="1 of 2 branches missed.">        if (isPaused) {</span>
<span class="fc" id="L1159">            System.out.println();</span>
<span class="fc" id="L1160">            println(&quot;Game is freezed!&quot;);</span>
        } else {
<span class="nc" id="L1162">            System.out.println();</span>
<span class="nc" id="L1163">            println(&quot;Let's gooooooooooo!&quot;);</span>
<span class="nc" id="L1164">            System.out.println();</span>
        }
<span class="fc" id="L1166">    }</span>

    /**
     * Checks if the game is currently paused.
     *
     * @return {@code true} if the game is paused, {@code false} otherwise
     */
    public boolean isPaused() {
<span class="fc" id="L1174">        return isPaused;</span>
    }

    /**
     * Checks if the game has ended.
     *
     * @return {@code true} if the game has ended, {@code false} otherwise
     */
    public boolean hasEnded() {
<span class="fc" id="L1183">        return levelFinish;</span>
    }

    /**
     * Checks if the level is currently in the completion phase.
     *
     * @return {@code true} if the level is completing, {@code false} otherwise
     */
    public boolean isCompleting() {
<span class="fc" id="L1192">        return isLevelCompleting;</span>
    }

    /**
     * Retrieves the list of all player-drawn lines.
     *
     * @return a list of {@link Line} objects
     */
    public List&lt;Line&gt; getLines() {
<span class="fc" id="L1201">        return Lines;</span>
    }

    /**
     * Removes a specific line from the list of player-drawn lines.
     *
     * @param line the {@link Line} to be removed
     */
    public void removeLines(Line line) {
<span class="fc" id="L1210">        Lines.remove(line);</span>
<span class="fc" id="L1211">    }</span>

    /**
     * Marks a ball for removal from the active balls list.
     *
     * @param ball the {@link Ball} to be removed
     */
    public void ballCatched(Ball ball) {
<span class="fc" id="L1219">        ballsToRemove.add(ball);</span>
<span class="fc" id="L1220">    }</span>

    /**
     * Adds a new ball to the spawn queue based on its color.
     *
     * @param colorString the color of the ball to be spawned
     */
    public void ballRefilled(String colorString) {
<span class="fc" id="L1228">        ballsToSpawn.add(colorString);</span>
<span class="fc" id="L1229">        println(&quot;Ball refilled: &quot; + colorString);</span>
<span class="fc" id="L1230">    }</span>

    /**
     * Increases the player's score by a specified amount.
     *
     * @param amount the amount to add to the score
     */
    public void addingScore(int amount) {
<span class="nc" id="L1238">        score += amount;</span>
<span class="nc" id="L1239">        println(&quot;Score added by &quot; + amount + &quot;. Total score: &quot; + score);</span>
<span class="nc" id="L1240">    }</span>

    /**
     * Decreases the player's score by a specified amount.
     *
     * @param amount the amount to subtract from the score
     */
    public void reducingScore(int amount) {
<span class="nc" id="L1248">        score -= amount;</span>
<span class="nc" id="L1249">        println(&quot;Score decreased by &quot; + amount + &quot;. Total score: &quot; + score);</span>
<span class="nc" id="L1250">    }</span>

    /**
     * Retrieves the score increment associated with capturing a hole of a specific color.
     *
     * @param colourString the color of the hole
     * @return the score increment value
     */
    public int getScoreWon(String colourString) {
<span class="fc" id="L1259">        return scoreWon.getOrDefault(colourString, 10);</span>
    }

    /**
     * Retrieves the score decrement associated with failing to capture a hole of a specific color.
     *
     * @param colourString the color of the hole
     * @return the score decrement value
     */
    public int getScoreLost(String colourString) {
<span class="fc" id="L1269">        return scoreLost.getOrDefault(colourString, 5);</span>
    }

    /**
     * Retrieves the score increase multiplier from the current level's configuration.
     *
     * @return the score increase multiplier
     */
    public float getIncreaseMultiplier() {
<span class="fc" id="L1278">        return currentLevel.getFloat(&quot;score_increase_from_hole_capture_modifier&quot;, 1.0f);</span>
    }

    /**
     * Retrieves the score decrease multiplier from the current level's configuration.
     *
     * @return the score decrease multiplier
     */
    public float getDecreaaseMultiplier() {
<span class="fc" id="L1287">        return currentLevel.getFloat(&quot;score_decrease_from_wrong_hole_modifier&quot;, 1.0f);</span>
    }

    /**
     * Retrieves the current score of the player.
     *
     * @return the player's score
     */
    public int getScore() {
<span class="fc" id="L1296">        return score;</span>
    }

    /**
     * Retrieves the current level index.
     *
     * @return the index of the current level
     */
    public int getCurrentLevelIndex() {
<span class="fc" id="L1305">        return currentLevelIndex;</span>
    }

    /**
     * Retrieves the list of active balls in the game.
     *
     * @return a list of {@link Ball} objects
     */
    public List&lt;Ball&gt; getBalls() {
<span class="fc" id="L1314">        return balls;</span>
    }

    /**
     * Retrieves the list of balls that are queued to be spawned.
     *
     * @return a list of ball color strings
     */
    public List&lt;String&gt; getBallsToSpawn() {
<span class="fc" id="L1323">        return ballsToSpawn;</span>
    }

    /**
     * Sets the remaining time left in the current level.
     *
     * @param time the time left in frames
     */
    public void setTimeLeft(int time) {
<span class="fc" id="L1332">        this.timeLeft = time;</span>
<span class="fc" id="L1333">    }</span>

    /**
     * Retrieves the remaining time left in the current level.
     *
     * @return the time left in frames
     */
    public int getTimeLeft() {
<span class="fc" id="L1341">        return timeLeft;</span>
    }

    /**
     * Checks if the level has finished based on the remaining time.
     * If the time has run out, it sets the levelFinish flag to true.
     */
    public void checkIfLevelFinished() {
<span class="pc bpc" id="L1349" title="1 of 2 branches missed.">        if (timeLeft &lt;= 0) {</span>
<span class="fc" id="L1350">            levelFinish = true;</span>
        }
<span class="fc" id="L1352">    }</span>

    /**
     * Retrieves the index of the first yellow tile.
     *
     * @return the index of yellowTile1
     */
    public int getYellowTile1() {
<span class="fc" id="L1360">        return yellowTile1;</span>
    }

    /**
     * Retrieves the index of the second yellow tile.
     *
     * @return the index of yellowTile2
     */
    public int getYellowTile2() {
<span class="fc" id="L1369">        return yellowTile2;</span>
    }

    /**
     * Retrieves the list of balls that are marked for removal.
     *
     * @return a list of {@link Ball} objects to remove
     */
    public List&lt;Ball&gt; getBallsToRemove() {
<span class="fc" id="L1378">        return ballsToRemove;</span>
    }

    /**
     * Retrieves the total number of edge tiles used for animating yellow tiles.
     *
     * @return the total number of edge tiles
     */
    public int getTotalEdgeTiles() {
<span class="fc" id="L1387">        return this.totalEdgeTiles;</span>
    }

    /**
     * Sets the path to the configuration file.
     *
     * @param configPath the path to the configuration JSON file
     */
    public void setConfigPath(String configPath) {
<span class="nc" id="L1396">        this.configPath = configPath;</span>
<span class="nc" id="L1397">    }</span>

    /**
     * The main entry point of the application.
     * Initializes and starts the Processing sketch.
     *
     * @param args command-line arguments (not used)
     */
    public static void main(String[] args) {
<span class="fc" id="L1406">        PApplet.main(&quot;inkball.App&quot;);</span>
<span class="fc" id="L1407">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>